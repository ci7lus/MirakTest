/* tslint:disable */
/* eslint-disable */
/**
 * Mirakurun
 * DVR Tuner Server Service for Chinachu Air.
 *
 * The version of the OpenAPI document: 3.5.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from "./configuration"
import globalAxios, { AxiosPromise, AxiosInstance } from "axios"
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from "./common"
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError,
} from "./base"

/**
 *
 * @export
 * @interface Channel
 */
export interface Channel {
  /**
   *
   * @type {ChannelType}
   * @memberof Channel
   */
  type: ChannelType
  /**
   *
   * @type {string}
   * @memberof Channel
   */
  channel: string
  /**
   *
   * @type {string}
   * @memberof Channel
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof Channel
   */
  satellite?: string
  /**
   *
   * @type {number}
   * @memberof Channel
   */
  space?: number
  /**
   *
   * @type {number}
   * @memberof Channel
   */
  freq?: number
  /**
   *
   * @type {string}
   * @memberof Channel
   */
  polarity?: ChannelPolarityEnum
  /**
   *
   * @type {Array<Service>}
   * @memberof Channel
   */
  services?: Array<Service>
}

/**
 * @export
 * @enum {string}
 */
export enum ChannelPolarityEnum {
  H = "H",
  V = "V",
}

/**
 *
 * @export
 * @enum {string}
 */
export enum ChannelType {
  Gr = "GR",
  Bs = "BS",
  Cs = "CS",
  Sky = "SKY",
}

/**
 *
 * @export
 * @interface ConfigChannelsItem
 */
export interface ConfigChannelsItem {
  /**
   *
   * @type {string}
   * @memberof ConfigChannelsItem
   */
  name: string
  /**
   *
   * @type {ChannelType}
   * @memberof ConfigChannelsItem
   */
  type: ChannelType
  /**
   *
   * @type {string}
   * @memberof ConfigChannelsItem
   */
  channel: string
  /**
   *
   * @type {number}
   * @memberof ConfigChannelsItem
   */
  serviceId?: number
  /**
   *
   * @type {string}
   * @memberof ConfigChannelsItem
   */
  satellite?: string
  /**
   *
   * @type {number}
   * @memberof ConfigChannelsItem
   */
  space?: number
  /**
   *
   * @type {number}
   * @memberof ConfigChannelsItem
   */
  freq?: number
  /**
   *
   * @type {string}
   * @memberof ConfigChannelsItem
   */
  polarity?: ConfigChannelsItemPolarityEnum
  /**
   *
   * @type {boolean}
   * @memberof ConfigChannelsItem
   */
  isDisabled?: boolean
}

/**
 * @export
 * @enum {string}
 */
export enum ConfigChannelsItemPolarityEnum {
  H = "H",
  V = "V",
}

/**
 *
 * @export
 * @interface ConfigServer
 */
export interface ConfigServer {
  /**
   *
   * @type {string}
   * @memberof ConfigServer
   */
  path?: string
  /**
   *
   * @type {number}
   * @memberof ConfigServer
   */
  port?: number
  /**
   *
   * @type {string}
   * @memberof ConfigServer
   */
  hostname?: string
  /**
   *
   * @type {boolean}
   * @memberof ConfigServer
   */
  disableIPv6?: boolean
  /**
   *
   * @type {number}
   * @memberof ConfigServer
   */
  logLevel?: number
  /**
   *
   * @type {number}
   * @memberof ConfigServer
   */
  maxLogHistory?: number
  /**
   *
   * @type {number}
   * @memberof ConfigServer
   */
  highWaterMark?: number
  /**
   *
   * @type {number}
   * @memberof ConfigServer
   */
  overflowTimeLimit?: number
  /**
   *
   * @type {number}
   * @memberof ConfigServer
   */
  maxBufferBytesBeforeReady?: number
  /**
   *
   * @type {number}
   * @memberof ConfigServer
   */
  eventEndTimeout?: number
  /**
   *
   * @type {number}
   * @memberof ConfigServer
   */
  programGCInterval?: number
  /**
   *
   * @type {number}
   * @memberof ConfigServer
   */
  epgGatheringInterval?: number
  /**
   *
   * @type {number}
   * @memberof ConfigServer
   */
  epgRetrievalTime?: number
  /**
   *
   * @type {boolean}
   * @memberof ConfigServer
   */
  disableEITParsing?: boolean
}
/**
 *
 * @export
 * @interface ConfigTunersItem
 */
export interface ConfigTunersItem {
  /**
   *
   * @type {string}
   * @memberof ConfigTunersItem
   */
  name: string
  /**
   *
   * @type {Array<ChannelType>}
   * @memberof ConfigTunersItem
   */
  types: Array<ChannelType>
  /**
   *
   * @type {string}
   * @memberof ConfigTunersItem
   */
  command?: string
  /**
   *
   * @type {string}
   * @memberof ConfigTunersItem
   */
  dvbDevicePath?: string
  /**
   *
   * @type {string}
   * @memberof ConfigTunersItem
   */
  remoteMirakurunHost?: string
  /**
   *
   * @type {number}
   * @memberof ConfigTunersItem
   */
  remoteMirakurunPort?: number
  /**
   *
   * @type {boolean}
   * @memberof ConfigTunersItem
   */
  remoteMirakurunDecoder?: boolean
  /**
   *
   * @type {string}
   * @memberof ConfigTunersItem
   */
  decoder?: string
  /**
   *
   * @type {boolean}
   * @memberof ConfigTunersItem
   */
  isDisabled?: boolean
}
/**
 *
 * @export
 * @interface ErrorOfOpenAPI
 */
export interface ErrorOfOpenAPI {
  /**
   *
   * @type {string}
   * @memberof ErrorOfOpenAPI
   */
  errorCode?: string
  /**
   *
   * @type {string}
   * @memberof ErrorOfOpenAPI
   */
  message?: string
  /**
   *
   * @type {string}
   * @memberof ErrorOfOpenAPI
   */
  location?: string
}
/**
 *
 * @export
 * @interface Event
 */
export interface Event {
  /**
   *
   * @type {EventResource}
   * @memberof Event
   */
  resource: EventResource
  /**
   *
   * @type {EventType}
   * @memberof Event
   */
  type: EventType
  /**
   *
   * @type {object}
   * @memberof Event
   */
  data: object
  /**
   *
   * @type {number}
   * @memberof Event
   */
  time: number
}
/**
 *
 * @export
 * @enum {string}
 */
export enum EventResource {
  Program = "program",
  Service = "service",
  Tuner = "tuner",
}

/**
 *
 * @export
 * @enum {string}
 */
export enum EventType {
  Create = "create",
  Update = "update",
  Redefine = "redefine",
}

/**
 *
 * @export
 * @interface ModelError
 */
export interface ModelError {
  /**
   *
   * @type {number}
   * @memberof ModelError
   */
  code?: number
  /**
   *
   * @type {string}
   * @memberof ModelError
   */
  reason?: string
  /**
   *
   * @type {Array<ErrorOfOpenAPI>}
   * @memberof ModelError
   */
  errors?: Array<ErrorOfOpenAPI>
}
/**
 *
 * @export
 * @interface Program
 */
export interface Program {
  /**
   *
   * @type {number}
   * @memberof Program
   */
  id: number
  /**
   *
   * @type {number}
   * @memberof Program
   */
  eventId: number
  /**
   *
   * @type {number}
   * @memberof Program
   */
  serviceId: number
  /**
   *
   * @type {number}
   * @memberof Program
   */
  networkId: number
  /**
   *
   * @type {number}
   * @memberof Program
   */
  startAt: number
  /**
   *
   * @type {number}
   * @memberof Program
   */
  duration: number
  /**
   *
   * @type {boolean}
   * @memberof Program
   */
  isFree: boolean
  /**
   *
   * @type {string}
   * @memberof Program
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof Program
   */
  description?: string
  /**
   *
   * @type {Array<ProgramGenre>}
   * @memberof Program
   */
  genres?: Array<ProgramGenre>
  /**
   *
   * @type {ProgramVideo}
   * @memberof Program
   */
  video?: ProgramVideo
  /**
   *
   * @type {ProgramAudio}
   * @memberof Program
   */
  audio?: ProgramAudio
  /**
   *
   * @type {object}
   * @memberof Program
   */
  extended?: object
  /**
   *
   * @type {Array<RelatedItem>}
   * @memberof Program
   */
  relatedItems?: Array<RelatedItem>
  /**
   *
   * @type {ProgramSeries}
   * @memberof Program
   */
  series?: ProgramSeries
}
/**
 *
 * @export
 * @interface ProgramAudio
 */
export interface ProgramAudio {
  /**
   *
   * @type {ProgramAudioSamplingRate}
   * @memberof ProgramAudio
   */
  samplingRate?: ProgramAudioSamplingRate
  /**
   *
   * @type {number}
   * @memberof ProgramAudio
   */
  componentType?: number
}
/**
 *
 * @export
 * @enum {string}
 */
export enum ProgramAudioSamplingRate {
  NUMBER_16000 = 16000,
  NUMBER_22050 = 22050,
  NUMBER_24000 = 24000,
  NUMBER_32000 = 32000,
  NUMBER_44100 = 44100,
  NUMBER_48000 = 48000,
}

/**
 *
 * @export
 * @interface ProgramGenre
 */
export interface ProgramGenre {
  /**
   *
   * @type {number}
   * @memberof ProgramGenre
   */
  lv1?: number
  /**
   *
   * @type {number}
   * @memberof ProgramGenre
   */
  lv2?: number
  /**
   *
   * @type {number}
   * @memberof ProgramGenre
   */
  un1?: number
  /**
   *
   * @type {number}
   * @memberof ProgramGenre
   */
  un2?: number
}
/**
 *
 * @export
 * @interface ProgramSeries
 */
export interface ProgramSeries {
  /**
   *
   * @type {number}
   * @memberof ProgramSeries
   */
  id?: number
  /**
   *
   * @type {number}
   * @memberof ProgramSeries
   */
  repeat?: number
  /**
   *
   * @type {number}
   * @memberof ProgramSeries
   */
  pattern?: number
  /**
   *
   * @type {number}
   * @memberof ProgramSeries
   */
  expiresAt?: number
  /**
   *
   * @type {number}
   * @memberof ProgramSeries
   */
  episode?: number
  /**
   *
   * @type {number}
   * @memberof ProgramSeries
   */
  lastEpisode?: number
  /**
   *
   * @type {string}
   * @memberof ProgramSeries
   */
  name?: string
}
/**
 *
 * @export
 * @interface ProgramVideo
 */
export interface ProgramVideo {
  /**
   *
   * @type {ProgramVideoType}
   * @memberof ProgramVideo
   */
  type?: ProgramVideoType
  /**
   *
   * @type {ProgramVideoResolution}
   * @memberof ProgramVideo
   */
  resolution?: ProgramVideoResolution
  /**
   *
   * @type {number}
   * @memberof ProgramVideo
   */
  streamContent?: number
  /**
   *
   * @type {number}
   * @memberof ProgramVideo
   */
  componentType?: number
}
/**
 *
 * @export
 * @enum {string}
 */
export enum ProgramVideoResolution {
  _240p = "240p",
  _480i = "480i",
  _480p = "480p",
  _720p = "720p",
  _1080i = "1080i",
  _1080p = "1080p",
  _2160p = "2160p",
  _4320p = "4320p",
}

/**
 *
 * @export
 * @enum {string}
 */
export enum ProgramVideoType {
  Mpeg2 = "mpeg2",
  H264 = "h.264",
  H265 = "h.265",
}

/**
 *
 * @export
 * @interface RelatedItem
 */
export interface RelatedItem {
  /**
   *
   * @type {number}
   * @memberof RelatedItem
   */
  networkId?: number
  /**
   *
   * @type {number}
   * @memberof RelatedItem
   */
  serviceId?: number
  /**
   *
   * @type {number}
   * @memberof RelatedItem
   */
  eventId?: number
}
/**
 *
 * @export
 * @interface Service
 */
export interface Service {
  /**
   *
   * @type {number}
   * @memberof Service
   */
  id: number
  /**
   *
   * @type {number}
   * @memberof Service
   */
  serviceId: number
  /**
   *
   * @type {number}
   * @memberof Service
   */
  networkId: number
  /**
   *
   * @type {string}
   * @memberof Service
   */
  name: string
  /**
   *
   * @type {number}
   * @memberof Service
   */
  logoId?: number
  /**
   *
   * @type {boolean}
   * @memberof Service
   */
  hasLogoData?: boolean
  /**
   *
   * @type {number}
   * @memberof Service
   */
  remoteControlKeyId?: number
  /**
   *
   * @type {Channel}
   * @memberof Service
   */
  channel?: Channel
}
/**
 *
 * @export
 * @interface Status
 */
export interface Status {
  /**
   *
   * @type {number}
   * @memberof Status
   */
  time?: number
  /**
   *
   * @type {string}
   * @memberof Status
   */
  version?: string
  /**
   *
   * @type {StatusProcess}
   * @memberof Status
   */
  process?: StatusProcess
  /**
   *
   * @type {StatusEpg}
   * @memberof Status
   */
  epg?: StatusEpg
  /**
   *
   * @type {StatusStreamCount}
   * @memberof Status
   */
  streamCount?: StatusStreamCount
  /**
   *
   * @type {StatusErrorCount}
   * @memberof Status
   */
  errorCount?: StatusErrorCount
  /**
   *
   * @type {StatusTimerAccuracy}
   * @memberof Status
   */
  timerAccuracy?: StatusTimerAccuracy
}
/**
 *
 * @export
 * @interface StatusEpg
 */
export interface StatusEpg {
  /**
   *
   * @type {Array<number>}
   * @memberof StatusEpg
   */
  gatheringNetworks?: Array<number>
  /**
   *
   * @type {number}
   * @memberof StatusEpg
   */
  storedEvents?: number
}
/**
 *
 * @export
 * @interface StatusErrorCount
 */
export interface StatusErrorCount {
  /**
   *
   * @type {number}
   * @memberof StatusErrorCount
   */
  uncaughtException?: number
  /**
   *
   * @type {number}
   * @memberof StatusErrorCount
   */
  unhandledRejection?: number
  /**
   *
   * @type {number}
   * @memberof StatusErrorCount
   */
  bufferOverflow?: number
  /**
   *
   * @type {number}
   * @memberof StatusErrorCount
   */
  tunerDeviceRespawn?: number
  /**
   *
   * @type {number}
   * @memberof StatusErrorCount
   */
  decoderRespawn?: number
}
/**
 *
 * @export
 * @interface StatusProcess
 */
export interface StatusProcess {
  /**
   *
   * @type {string}
   * @memberof StatusProcess
   */
  arch?: string
  /**
   *
   * @type {string}
   * @memberof StatusProcess
   */
  platform?: string
  /**
   *
   * @type {object}
   * @memberof StatusProcess
   */
  versions?: object
  /**
   *
   * @type {object}
   * @memberof StatusProcess
   */
  env?: object
  /**
   *
   * @type {number}
   * @memberof StatusProcess
   */
  pid?: number
  /**
   *
   * @type {StatusProcessMemoryUsage}
   * @memberof StatusProcess
   */
  memoryUsage?: StatusProcessMemoryUsage
}
/**
 *
 * @export
 * @interface StatusProcessMemoryUsage
 */
export interface StatusProcessMemoryUsage {
  /**
   *
   * @type {number}
   * @memberof StatusProcessMemoryUsage
   */
  rss?: number
  /**
   *
   * @type {number}
   * @memberof StatusProcessMemoryUsage
   */
  heapTotal?: number
  /**
   *
   * @type {number}
   * @memberof StatusProcessMemoryUsage
   */
  heapUsed?: number
}
/**
 *
 * @export
 * @interface StatusStreamCount
 */
export interface StatusStreamCount {
  /**
   *
   * @type {number}
   * @memberof StatusStreamCount
   */
  tunerDevice?: number
  /**
   *
   * @type {number}
   * @memberof StatusStreamCount
   */
  tsFilter?: number
  /**
   *
   * @type {number}
   * @memberof StatusStreamCount
   */
  decoder?: number
}
/**
 *
 * @export
 * @interface StatusTimerAccuracy
 */
export interface StatusTimerAccuracy {
  /**
   *
   * @type {number}
   * @memberof StatusTimerAccuracy
   */
  last?: number
  /**
   *
   * @type {StatusTimerAccuracyM1}
   * @memberof StatusTimerAccuracy
   */
  m1?: StatusTimerAccuracyM1
  /**
   *
   * @type {StatusTimerAccuracyM1}
   * @memberof StatusTimerAccuracy
   */
  m5?: StatusTimerAccuracyM1
  /**
   *
   * @type {StatusTimerAccuracyM1}
   * @memberof StatusTimerAccuracy
   */
  m15?: StatusTimerAccuracyM1
}
/**
 *
 * @export
 * @interface StatusTimerAccuracyM1
 */
export interface StatusTimerAccuracyM1 {
  /**
   *
   * @type {number}
   * @memberof StatusTimerAccuracyM1
   */
  avg?: number
  /**
   *
   * @type {number}
   * @memberof StatusTimerAccuracyM1
   */
  min?: number
  /**
   *
   * @type {number}
   * @memberof StatusTimerAccuracyM1
   */
  max?: number
}
/**
 *
 * @export
 * @interface TunerDevice
 */
export interface TunerDevice {
  /**
   *
   * @type {number}
   * @memberof TunerDevice
   */
  index: number
  /**
   *
   * @type {string}
   * @memberof TunerDevice
   */
  name: string
  /**
   *
   * @type {Array<ChannelType>}
   * @memberof TunerDevice
   */
  types: Array<ChannelType>
  /**
   *
   * @type {string}
   * @memberof TunerDevice
   */
  command: string
  /**
   *
   * @type {number}
   * @memberof TunerDevice
   */
  pid: number
  /**
   *
   * @type {Array<TunerUser>}
   * @memberof TunerDevice
   */
  users: Array<TunerUser>
  /**
   *
   * @type {boolean}
   * @memberof TunerDevice
   */
  isAvailable: boolean
  /**
   *
   * @type {boolean}
   * @memberof TunerDevice
   */
  isRemote?: boolean
  /**
   *
   * @type {boolean}
   * @memberof TunerDevice
   */
  isFree: boolean
  /**
   *
   * @type {boolean}
   * @memberof TunerDevice
   */
  isUsing: boolean
  /**
   *
   * @type {boolean}
   * @memberof TunerDevice
   */
  isFault: boolean
}
/**
 *
 * @export
 * @interface TunerProcess
 */
export interface TunerProcess {
  /**
   *
   * @type {number}
   * @memberof TunerProcess
   */
  pid: number
}
/**
 *
 * @export
 * @interface TunerUser
 */
export interface TunerUser {
  /**
   *
   * @type {string}
   * @memberof TunerUser
   */
  id: string
  /**
   *
   * @type {number}
   * @memberof TunerUser
   */
  priority: number
  /**
   *
   * @type {string}
   * @memberof TunerUser
   */
  agent?: string
  /**
   *
   * @type {string}
   * @memberof TunerUser
   */
  url?: string
  /**
   *
   * @type {boolean}
   * @memberof TunerUser
   */
  disableDecoder?: boolean
  /**
   *
   * @type {TunerUserStreamSetting}
   * @memberof TunerUser
   */
  streamSetting?: TunerUserStreamSetting
  /**
   *
   * @type {{ [key: string]: TunerUserStreamInfo; }}
   * @memberof TunerUser
   */
  streamInfo?: { [key: string]: TunerUserStreamInfo }
}
/**
 *
 * @export
 * @interface TunerUserStreamInfo
 */
export interface TunerUserStreamInfo {
  /**
   *
   * @type {number}
   * @memberof TunerUserStreamInfo
   */
  packet: number
  /**
   *
   * @type {number}
   * @memberof TunerUserStreamInfo
   */
  drop: number
}
/**
 *
 * @export
 * @interface TunerUserStreamSetting
 */
export interface TunerUserStreamSetting {
  /**
   *
   * @type {ConfigChannelsItem}
   * @memberof TunerUserStreamSetting
   */
  channel: ConfigChannelsItem
  /**
   *
   * @type {number}
   * @memberof TunerUserStreamSetting
   */
  networkId?: number
  /**
   *
   * @type {number}
   * @memberof TunerUserStreamSetting
   */
  serviceId?: number
  /**
   *
   * @type {number}
   * @memberof TunerUserStreamSetting
   */
  eventId?: number
  /**
   *
   * @type {boolean}
   * @memberof TunerUserStreamSetting
   */
  noProvide?: boolean
  /**
   *
   * @type {boolean}
   * @memberof TunerUserStreamSetting
   */
  parseNIT?: boolean
  /**
   *
   * @type {boolean}
   * @memberof TunerUserStreamSetting
   */
  parseSDT?: boolean
  /**
   *
   * @type {boolean}
   * @memberof TunerUserStreamSetting
   */
  parseEIT?: boolean
}
/**
 *
 * @export
 * @interface Version
 */
export interface Version {
  /**
   *
   * @type {string}
   * @memberof Version
   */
  current?: string
  /**
   *
   * @type {string}
   * @memberof Version
   */
  latest?: string
}

/**
 * ChannelsApi - axios parameter creator
 * @export
 */
export const ChannelsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {'GR' | 'BS' | 'CS' | 'SKY'} type
     * @param {string} channel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getChannel: async (
      type: "GR" | "BS" | "CS" | "SKY",
      channel: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'type' is not null or undefined
      assertParamExists("getChannel", "type", type)
      // verify required parameter 'channel' is not null or undefined
      assertParamExists("getChannel", "channel", channel)
      const localVarPath = `/channels/{type}/{channel}`
        .replace(`{${"type"}}`, encodeURIComponent(String(type)))
        .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {'GR' | 'BS' | 'CS' | 'SKY'} type
     * @param {string} channel
     * @param {number} [xMirakurunPriority]
     * @param {number} [decode]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getChannelStream: async (
      type: "GR" | "BS" | "CS" | "SKY",
      channel: string,
      xMirakurunPriority?: number,
      decode?: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'type' is not null or undefined
      assertParamExists("getChannelStream", "type", type)
      // verify required parameter 'channel' is not null or undefined
      assertParamExists("getChannelStream", "channel", channel)
      const localVarPath = `/channels/{type}/{channel}/stream`
        .replace(`{${"type"}}`, encodeURIComponent(String(type)))
        .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (decode !== undefined) {
        localVarQueryParameter["decode"] = decode
      }

      if (xMirakurunPriority !== undefined && xMirakurunPriority !== null) {
        localVarHeaderParameter["X-Mirakurun-Priority"] = String(
          JSON.stringify(xMirakurunPriority)
        )
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {'GR' | 'BS' | 'CS' | 'SKY'} [type]
     * @param {string} [channel]
     * @param {string} [name]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getChannels: async (
      type?: "GR" | "BS" | "CS" | "SKY",
      channel?: string,
      name?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/channels`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (type !== undefined) {
        localVarQueryParameter["type"] = type
      }

      if (channel !== undefined) {
        localVarQueryParameter["channel"] = channel
      }

      if (name !== undefined) {
        localVarQueryParameter["name"] = name
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {'GR' | 'BS' | 'CS' | 'SKY'} type
     * @param {string} [channel]
     * @param {string} [name]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getChannelsByType: async (
      type: "GR" | "BS" | "CS" | "SKY",
      channel?: string,
      name?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'type' is not null or undefined
      assertParamExists("getChannelsByType", "type", type)
      const localVarPath = `/channels/{type}`.replace(
        `{${"type"}}`,
        encodeURIComponent(String(type))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (channel !== undefined) {
        localVarQueryParameter["channel"] = channel
      }

      if (name !== undefined) {
        localVarQueryParameter["name"] = name
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {'GR' | 'BS' | 'CS' | 'SKY'} type
     * @param {string} channel
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getServiceByChannel: async (
      type: "GR" | "BS" | "CS" | "SKY",
      channel: string,
      id: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'type' is not null or undefined
      assertParamExists("getServiceByChannel", "type", type)
      // verify required parameter 'channel' is not null or undefined
      assertParamExists("getServiceByChannel", "channel", channel)
      // verify required parameter 'id' is not null or undefined
      assertParamExists("getServiceByChannel", "id", id)
      const localVarPath = `/channels/{type}/{channel}/services/{id}`
        .replace(`{${"type"}}`, encodeURIComponent(String(type)))
        .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
        .replace(`{${"id"}}`, encodeURIComponent(String(id)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {'GR' | 'BS' | 'CS' | 'SKY'} type
     * @param {string} channel
     * @param {number} id
     * @param {number} [xMirakurunPriority]
     * @param {number} [decode]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getServiceStreamByChannel: async (
      type: "GR" | "BS" | "CS" | "SKY",
      channel: string,
      id: number,
      xMirakurunPriority?: number,
      decode?: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'type' is not null or undefined
      assertParamExists("getServiceStreamByChannel", "type", type)
      // verify required parameter 'channel' is not null or undefined
      assertParamExists("getServiceStreamByChannel", "channel", channel)
      // verify required parameter 'id' is not null or undefined
      assertParamExists("getServiceStreamByChannel", "id", id)
      const localVarPath = `/channels/{type}/{channel}/services/{id}/stream`
        .replace(`{${"type"}}`, encodeURIComponent(String(type)))
        .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
        .replace(`{${"id"}}`, encodeURIComponent(String(id)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (decode !== undefined) {
        localVarQueryParameter["decode"] = decode
      }

      if (xMirakurunPriority !== undefined && xMirakurunPriority !== null) {
        localVarHeaderParameter["X-Mirakurun-Priority"] = String(
          JSON.stringify(xMirakurunPriority)
        )
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {'GR' | 'BS' | 'CS' | 'SKY'} type
     * @param {string} channel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getServicesByChannel: async (
      type: "GR" | "BS" | "CS" | "SKY",
      channel: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'type' is not null or undefined
      assertParamExists("getServicesByChannel", "type", type)
      // verify required parameter 'channel' is not null or undefined
      assertParamExists("getServicesByChannel", "channel", channel)
      const localVarPath = `/channels/{type}/{channel}/services`
        .replace(`{${"type"}}`, encodeURIComponent(String(type)))
        .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ChannelsApi - functional programming interface
 * @export
 */
export const ChannelsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ChannelsApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @param {'GR' | 'BS' | 'CS' | 'SKY'} type
     * @param {string} channel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getChannel(
      type: "GR" | "BS" | "CS" | "SKY",
      channel: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Channel>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getChannel(
        type,
        channel,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {'GR' | 'BS' | 'CS' | 'SKY'} type
     * @param {string} channel
     * @param {number} [xMirakurunPriority]
     * @param {number} [decode]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getChannelStream(
      type: "GR" | "BS" | "CS" | "SKY",
      channel: string,
      xMirakurunPriority?: number,
      decode?: number,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getChannelStream(
        type,
        channel,
        xMirakurunPriority,
        decode,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {'GR' | 'BS' | 'CS' | 'SKY'} [type]
     * @param {string} [channel]
     * @param {string} [name]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getChannels(
      type?: "GR" | "BS" | "CS" | "SKY",
      channel?: string,
      name?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Channel>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getChannels(
        type,
        channel,
        name,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {'GR' | 'BS' | 'CS' | 'SKY'} type
     * @param {string} [channel]
     * @param {string} [name]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getChannelsByType(
      type: "GR" | "BS" | "CS" | "SKY",
      channel?: string,
      name?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Channel>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getChannelsByType(
        type,
        channel,
        name,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {'GR' | 'BS' | 'CS' | 'SKY'} type
     * @param {string} channel
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getServiceByChannel(
      type: "GR" | "BS" | "CS" | "SKY",
      channel: string,
      id: number,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Service>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getServiceByChannel(
        type,
        channel,
        id,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {'GR' | 'BS' | 'CS' | 'SKY'} type
     * @param {string} channel
     * @param {number} id
     * @param {number} [xMirakurunPriority]
     * @param {number} [decode]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getServiceStreamByChannel(
      type: "GR" | "BS" | "CS" | "SKY",
      channel: string,
      id: number,
      xMirakurunPriority?: number,
      decode?: number,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getServiceStreamByChannel(
        type,
        channel,
        id,
        xMirakurunPriority,
        decode,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {'GR' | 'BS' | 'CS' | 'SKY'} type
     * @param {string} channel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getServicesByChannel(
      type: "GR" | "BS" | "CS" | "SKY",
      channel: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Service>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getServicesByChannel(
        type,
        channel,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
  }
}

/**
 * ChannelsApi - factory interface
 * @export
 */
export const ChannelsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ChannelsApiFp(configuration)
  return {
    /**
     *
     * @param {'GR' | 'BS' | 'CS' | 'SKY'} type
     * @param {string} channel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getChannel(
      type: "GR" | "BS" | "CS" | "SKY",
      channel: string,
      options?: any
    ): AxiosPromise<Channel> {
      return localVarFp
        .getChannel(type, channel, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {'GR' | 'BS' | 'CS' | 'SKY'} type
     * @param {string} channel
     * @param {number} [xMirakurunPriority]
     * @param {number} [decode]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getChannelStream(
      type: "GR" | "BS" | "CS" | "SKY",
      channel: string,
      xMirakurunPriority?: number,
      decode?: number,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .getChannelStream(type, channel, xMirakurunPriority, decode, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {'GR' | 'BS' | 'CS' | 'SKY'} [type]
     * @param {string} [channel]
     * @param {string} [name]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getChannels(
      type?: "GR" | "BS" | "CS" | "SKY",
      channel?: string,
      name?: string,
      options?: any
    ): AxiosPromise<Array<Channel>> {
      return localVarFp
        .getChannels(type, channel, name, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {'GR' | 'BS' | 'CS' | 'SKY'} type
     * @param {string} [channel]
     * @param {string} [name]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getChannelsByType(
      type: "GR" | "BS" | "CS" | "SKY",
      channel?: string,
      name?: string,
      options?: any
    ): AxiosPromise<Array<Channel>> {
      return localVarFp
        .getChannelsByType(type, channel, name, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {'GR' | 'BS' | 'CS' | 'SKY'} type
     * @param {string} channel
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getServiceByChannel(
      type: "GR" | "BS" | "CS" | "SKY",
      channel: string,
      id: number,
      options?: any
    ): AxiosPromise<Array<Service>> {
      return localVarFp
        .getServiceByChannel(type, channel, id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {'GR' | 'BS' | 'CS' | 'SKY'} type
     * @param {string} channel
     * @param {number} id
     * @param {number} [xMirakurunPriority]
     * @param {number} [decode]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getServiceStreamByChannel(
      type: "GR" | "BS" | "CS" | "SKY",
      channel: string,
      id: number,
      xMirakurunPriority?: number,
      decode?: number,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .getServiceStreamByChannel(
          type,
          channel,
          id,
          xMirakurunPriority,
          decode,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {'GR' | 'BS' | 'CS' | 'SKY'} type
     * @param {string} channel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getServicesByChannel(
      type: "GR" | "BS" | "CS" | "SKY",
      channel: string,
      options?: any
    ): AxiosPromise<Array<Service>> {
      return localVarFp
        .getServicesByChannel(type, channel, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * ChannelsApi - object-oriented interface
 * @export
 * @class ChannelsApi
 * @extends {BaseAPI}
 */
export class ChannelsApi extends BaseAPI {
  /**
   *
   * @param {'GR' | 'BS' | 'CS' | 'SKY'} type
   * @param {string} channel
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChannelsApi
   */
  public getChannel(
    type: "GR" | "BS" | "CS" | "SKY",
    channel: string,
    options?: any
  ) {
    return ChannelsApiFp(this.configuration)
      .getChannel(type, channel, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {'GR' | 'BS' | 'CS' | 'SKY'} type
   * @param {string} channel
   * @param {number} [xMirakurunPriority]
   * @param {number} [decode]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChannelsApi
   */
  public getChannelStream(
    type: "GR" | "BS" | "CS" | "SKY",
    channel: string,
    xMirakurunPriority?: number,
    decode?: number,
    options?: any
  ) {
    return ChannelsApiFp(this.configuration)
      .getChannelStream(type, channel, xMirakurunPriority, decode, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {'GR' | 'BS' | 'CS' | 'SKY'} [type]
   * @param {string} [channel]
   * @param {string} [name]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChannelsApi
   */
  public getChannels(
    type?: "GR" | "BS" | "CS" | "SKY",
    channel?: string,
    name?: string,
    options?: any
  ) {
    return ChannelsApiFp(this.configuration)
      .getChannels(type, channel, name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {'GR' | 'BS' | 'CS' | 'SKY'} type
   * @param {string} [channel]
   * @param {string} [name]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChannelsApi
   */
  public getChannelsByType(
    type: "GR" | "BS" | "CS" | "SKY",
    channel?: string,
    name?: string,
    options?: any
  ) {
    return ChannelsApiFp(this.configuration)
      .getChannelsByType(type, channel, name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {'GR' | 'BS' | 'CS' | 'SKY'} type
   * @param {string} channel
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChannelsApi
   */
  public getServiceByChannel(
    type: "GR" | "BS" | "CS" | "SKY",
    channel: string,
    id: number,
    options?: any
  ) {
    return ChannelsApiFp(this.configuration)
      .getServiceByChannel(type, channel, id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {'GR' | 'BS' | 'CS' | 'SKY'} type
   * @param {string} channel
   * @param {number} id
   * @param {number} [xMirakurunPriority]
   * @param {number} [decode]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChannelsApi
   */
  public getServiceStreamByChannel(
    type: "GR" | "BS" | "CS" | "SKY",
    channel: string,
    id: number,
    xMirakurunPriority?: number,
    decode?: number,
    options?: any
  ) {
    return ChannelsApiFp(this.configuration)
      .getServiceStreamByChannel(
        type,
        channel,
        id,
        xMirakurunPriority,
        decode,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {'GR' | 'BS' | 'CS' | 'SKY'} type
   * @param {string} channel
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChannelsApi
   */
  public getServicesByChannel(
    type: "GR" | "BS" | "CS" | "SKY",
    channel: string,
    options?: any
  ) {
    return ChannelsApiFp(this.configuration)
      .getServicesByChannel(type, channel, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * ConfigApi - axios parameter creator
 * @export
 */
export const ConfigApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Entry rewriting specifications: - The scan is performed on a range of channels of the specified type and the entries for those channels, if any, are saved in the configuration file. - If the channel to be scanned is described in the configuration file and is enabled, the scan will not be performed for that channel and the entries described will remain intact. If you do not want to keep the entries, use the `refresh` option. - All entries outside the channel range of the specified type will be deleted. - All entries of a type other than the specified type will remain.  About BS Subchannel Style: - Only when scanning BS, you can specify the channel number in the subchannel style (e.g. BS01_0). To specify the channel number, use minSubCh and maxSubCh in addition to minCh and maxCh. - The subchannel number parameters (minSubCh, maxSubCh) are used only if the type is BS and are ignored otherwise. - Subchannel style scans scan in the following range:     From `BS${minCh}_${minSubCh}` to `BS${maxCh}_${maxSubCh}` - In the subchannel style, minCh and maxCh are zero padded to two digits. minSubCh and maxSubCh are not padded. - BS \"non\" subchannel style scans and GR scans are basically the same. Note that if you scan the wrong channel range, the GR channel will be registered as BS and the BS channel will be registered as GR. This problem does not occur because CS scan uses a character string with `CS` added as a channel number prefix.
     * @summary Scan the receivable channels and rewrite the channel settings.
     * @param {'GR' | 'BS' | 'CS'} [type] Specifies the channel type to scan.
     * @param {number} [minCh] Specifies the minimum number of channel numbers to scan.
     * @param {number} [maxCh] Specifies the maximum number of channel numbers to scan.
     * @param {number} [minSubCh] Specifies the minimum number of subchannel numbers to scan. This parameter is only used if the type is &#x60;BS&#x60; and the bs_subch_style is &#x60;true&#x60;.
     * @param {number} [maxSubCh] Specifies the maximum number of subchannel numbers to scan. This parameter is only used if the type is &#x60;BS&#x60; and the bs_subch_style is &#x60;true&#x60;.
     * @param {boolean} [useSubCh] Specify true to specify the channel in the subchannel style. Only used for BS scans. (e.g. BS01_0)
     * @param {'Channel' | 'Service'} [registerMode] When you register the scanned channel information, specify whether you want to register it by channel or by service.  _Default value (GR)_: Channel _Default value (BS/CS)_: Service
     * @param {boolean} [registerOnDisabled] If &#x60;true&#x60;, disable the channel setting during registration.  _Default value (GR)_: false _Default value (BS/CS)_: true
     * @param {boolean} [refresh] If &#x60;true&#x60;, update the existing settings without inheriting them. However, non-scanned types of channels will always be inherited.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    channelScan: async (
      type?: "GR" | "BS" | "CS",
      minCh?: number,
      maxCh?: number,
      minSubCh?: number,
      maxSubCh?: number,
      useSubCh?: boolean,
      registerMode?: "Channel" | "Service",
      registerOnDisabled?: boolean,
      refresh?: boolean,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/config/channels/scan`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (type !== undefined) {
        localVarQueryParameter["type"] = type
      }

      if (minCh !== undefined) {
        localVarQueryParameter["minCh"] = minCh
      }

      if (maxCh !== undefined) {
        localVarQueryParameter["maxCh"] = maxCh
      }

      if (minSubCh !== undefined) {
        localVarQueryParameter["minSubCh"] = minSubCh
      }

      if (maxSubCh !== undefined) {
        localVarQueryParameter["maxSubCh"] = maxSubCh
      }

      if (useSubCh !== undefined) {
        localVarQueryParameter["useSubCh"] = useSubCh
      }

      if (registerMode !== undefined) {
        localVarQueryParameter["registerMode"] = registerMode
      }

      if (registerOnDisabled !== undefined) {
        localVarQueryParameter["registerOnDisabled"] = registerOnDisabled
      }

      if (refresh !== undefined) {
        localVarQueryParameter["refresh"] = refresh
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getChannelsConfig: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/config/channels`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getServerConfig: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/config/server`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTunersConfig: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/config/tuners`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {Array<ConfigChannelsItem>} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateChannelsConfig: async (
      body?: Array<ConfigChannelsItem>,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/config/channels`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter["Content-Type"] = "application/json"

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {ConfigServer} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateServerConfig: async (
      body?: ConfigServer,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/config/server`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter["Content-Type"] = "application/json"

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {Array<ConfigTunersItem>} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateTunersConfig: async (
      body?: Array<ConfigTunersItem>,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/config/tuners`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter["Content-Type"] = "application/json"

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ConfigApi - functional programming interface
 * @export
 */
export const ConfigApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ConfigApiAxiosParamCreator(configuration)
  return {
    /**
     * Entry rewriting specifications: - The scan is performed on a range of channels of the specified type and the entries for those channels, if any, are saved in the configuration file. - If the channel to be scanned is described in the configuration file and is enabled, the scan will not be performed for that channel and the entries described will remain intact. If you do not want to keep the entries, use the `refresh` option. - All entries outside the channel range of the specified type will be deleted. - All entries of a type other than the specified type will remain.  About BS Subchannel Style: - Only when scanning BS, you can specify the channel number in the subchannel style (e.g. BS01_0). To specify the channel number, use minSubCh and maxSubCh in addition to minCh and maxCh. - The subchannel number parameters (minSubCh, maxSubCh) are used only if the type is BS and are ignored otherwise. - Subchannel style scans scan in the following range:     From `BS${minCh}_${minSubCh}` to `BS${maxCh}_${maxSubCh}` - In the subchannel style, minCh and maxCh are zero padded to two digits. minSubCh and maxSubCh are not padded. - BS \"non\" subchannel style scans and GR scans are basically the same. Note that if you scan the wrong channel range, the GR channel will be registered as BS and the BS channel will be registered as GR. This problem does not occur because CS scan uses a character string with `CS` added as a channel number prefix.
     * @summary Scan the receivable channels and rewrite the channel settings.
     * @param {'GR' | 'BS' | 'CS'} [type] Specifies the channel type to scan.
     * @param {number} [minCh] Specifies the minimum number of channel numbers to scan.
     * @param {number} [maxCh] Specifies the maximum number of channel numbers to scan.
     * @param {number} [minSubCh] Specifies the minimum number of subchannel numbers to scan. This parameter is only used if the type is &#x60;BS&#x60; and the bs_subch_style is &#x60;true&#x60;.
     * @param {number} [maxSubCh] Specifies the maximum number of subchannel numbers to scan. This parameter is only used if the type is &#x60;BS&#x60; and the bs_subch_style is &#x60;true&#x60;.
     * @param {boolean} [useSubCh] Specify true to specify the channel in the subchannel style. Only used for BS scans. (e.g. BS01_0)
     * @param {'Channel' | 'Service'} [registerMode] When you register the scanned channel information, specify whether you want to register it by channel or by service.  _Default value (GR)_: Channel _Default value (BS/CS)_: Service
     * @param {boolean} [registerOnDisabled] If &#x60;true&#x60;, disable the channel setting during registration.  _Default value (GR)_: false _Default value (BS/CS)_: true
     * @param {boolean} [refresh] If &#x60;true&#x60;, update the existing settings without inheriting them. However, non-scanned types of channels will always be inherited.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async channelScan(
      type?: "GR" | "BS" | "CS",
      minCh?: number,
      maxCh?: number,
      minSubCh?: number,
      maxSubCh?: number,
      useSubCh?: boolean,
      registerMode?: "Channel" | "Service",
      registerOnDisabled?: boolean,
      refresh?: boolean,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.channelScan(
        type,
        minCh,
        maxCh,
        minSubCh,
        maxSubCh,
        useSubCh,
        registerMode,
        registerOnDisabled,
        refresh,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getChannelsConfig(
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<ConfigChannelsItem>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getChannelsConfig(
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getServerConfig(
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfigServer>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getServerConfig(
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTunersConfig(
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<ConfigTunersItem>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getTunersConfig(
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {Array<ConfigChannelsItem>} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateChannelsConfig(
      body?: Array<ConfigChannelsItem>,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<ConfigChannelsItem>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateChannelsConfig(
        body,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {ConfigServer} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateServerConfig(
      body?: ConfigServer,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfigServer>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateServerConfig(
        body,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {Array<ConfigTunersItem>} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateTunersConfig(
      body?: Array<ConfigTunersItem>,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<ConfigTunersItem>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateTunersConfig(
        body,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
  }
}

/**
 * ConfigApi - factory interface
 * @export
 */
export const ConfigApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ConfigApiFp(configuration)
  return {
    /**
     * Entry rewriting specifications: - The scan is performed on a range of channels of the specified type and the entries for those channels, if any, are saved in the configuration file. - If the channel to be scanned is described in the configuration file and is enabled, the scan will not be performed for that channel and the entries described will remain intact. If you do not want to keep the entries, use the `refresh` option. - All entries outside the channel range of the specified type will be deleted. - All entries of a type other than the specified type will remain.  About BS Subchannel Style: - Only when scanning BS, you can specify the channel number in the subchannel style (e.g. BS01_0). To specify the channel number, use minSubCh and maxSubCh in addition to minCh and maxCh. - The subchannel number parameters (minSubCh, maxSubCh) are used only if the type is BS and are ignored otherwise. - Subchannel style scans scan in the following range:     From `BS${minCh}_${minSubCh}` to `BS${maxCh}_${maxSubCh}` - In the subchannel style, minCh and maxCh are zero padded to two digits. minSubCh and maxSubCh are not padded. - BS \"non\" subchannel style scans and GR scans are basically the same. Note that if you scan the wrong channel range, the GR channel will be registered as BS and the BS channel will be registered as GR. This problem does not occur because CS scan uses a character string with `CS` added as a channel number prefix.
     * @summary Scan the receivable channels and rewrite the channel settings.
     * @param {'GR' | 'BS' | 'CS'} [type] Specifies the channel type to scan.
     * @param {number} [minCh] Specifies the minimum number of channel numbers to scan.
     * @param {number} [maxCh] Specifies the maximum number of channel numbers to scan.
     * @param {number} [minSubCh] Specifies the minimum number of subchannel numbers to scan. This parameter is only used if the type is &#x60;BS&#x60; and the bs_subch_style is &#x60;true&#x60;.
     * @param {number} [maxSubCh] Specifies the maximum number of subchannel numbers to scan. This parameter is only used if the type is &#x60;BS&#x60; and the bs_subch_style is &#x60;true&#x60;.
     * @param {boolean} [useSubCh] Specify true to specify the channel in the subchannel style. Only used for BS scans. (e.g. BS01_0)
     * @param {'Channel' | 'Service'} [registerMode] When you register the scanned channel information, specify whether you want to register it by channel or by service.  _Default value (GR)_: Channel _Default value (BS/CS)_: Service
     * @param {boolean} [registerOnDisabled] If &#x60;true&#x60;, disable the channel setting during registration.  _Default value (GR)_: false _Default value (BS/CS)_: true
     * @param {boolean} [refresh] If &#x60;true&#x60;, update the existing settings without inheriting them. However, non-scanned types of channels will always be inherited.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    channelScan(
      type?: "GR" | "BS" | "CS",
      minCh?: number,
      maxCh?: number,
      minSubCh?: number,
      maxSubCh?: number,
      useSubCh?: boolean,
      registerMode?: "Channel" | "Service",
      registerOnDisabled?: boolean,
      refresh?: boolean,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .channelScan(
          type,
          minCh,
          maxCh,
          minSubCh,
          maxSubCh,
          useSubCh,
          registerMode,
          registerOnDisabled,
          refresh,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getChannelsConfig(options?: any): AxiosPromise<Array<ConfigChannelsItem>> {
      return localVarFp
        .getChannelsConfig(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getServerConfig(options?: any): AxiosPromise<ConfigServer> {
      return localVarFp
        .getServerConfig(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTunersConfig(options?: any): AxiosPromise<Array<ConfigTunersItem>> {
      return localVarFp
        .getTunersConfig(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {Array<ConfigChannelsItem>} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateChannelsConfig(
      body?: Array<ConfigChannelsItem>,
      options?: any
    ): AxiosPromise<Array<ConfigChannelsItem>> {
      return localVarFp
        .updateChannelsConfig(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {ConfigServer} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateServerConfig(
      body?: ConfigServer,
      options?: any
    ): AxiosPromise<ConfigServer> {
      return localVarFp
        .updateServerConfig(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {Array<ConfigTunersItem>} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateTunersConfig(
      body?: Array<ConfigTunersItem>,
      options?: any
    ): AxiosPromise<Array<ConfigTunersItem>> {
      return localVarFp
        .updateTunersConfig(body, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * ConfigApi - object-oriented interface
 * @export
 * @class ConfigApi
 * @extends {BaseAPI}
 */
export class ConfigApi extends BaseAPI {
  /**
   * Entry rewriting specifications: - The scan is performed on a range of channels of the specified type and the entries for those channels, if any, are saved in the configuration file. - If the channel to be scanned is described in the configuration file and is enabled, the scan will not be performed for that channel and the entries described will remain intact. If you do not want to keep the entries, use the `refresh` option. - All entries outside the channel range of the specified type will be deleted. - All entries of a type other than the specified type will remain.  About BS Subchannel Style: - Only when scanning BS, you can specify the channel number in the subchannel style (e.g. BS01_0). To specify the channel number, use minSubCh and maxSubCh in addition to minCh and maxCh. - The subchannel number parameters (minSubCh, maxSubCh) are used only if the type is BS and are ignored otherwise. - Subchannel style scans scan in the following range:     From `BS${minCh}_${minSubCh}` to `BS${maxCh}_${maxSubCh}` - In the subchannel style, minCh and maxCh are zero padded to two digits. minSubCh and maxSubCh are not padded. - BS \"non\" subchannel style scans and GR scans are basically the same. Note that if you scan the wrong channel range, the GR channel will be registered as BS and the BS channel will be registered as GR. This problem does not occur because CS scan uses a character string with `CS` added as a channel number prefix.
   * @summary Scan the receivable channels and rewrite the channel settings.
   * @param {'GR' | 'BS' | 'CS'} [type] Specifies the channel type to scan.
   * @param {number} [minCh] Specifies the minimum number of channel numbers to scan.
   * @param {number} [maxCh] Specifies the maximum number of channel numbers to scan.
   * @param {number} [minSubCh] Specifies the minimum number of subchannel numbers to scan. This parameter is only used if the type is &#x60;BS&#x60; and the bs_subch_style is &#x60;true&#x60;.
   * @param {number} [maxSubCh] Specifies the maximum number of subchannel numbers to scan. This parameter is only used if the type is &#x60;BS&#x60; and the bs_subch_style is &#x60;true&#x60;.
   * @param {boolean} [useSubCh] Specify true to specify the channel in the subchannel style. Only used for BS scans. (e.g. BS01_0)
   * @param {'Channel' | 'Service'} [registerMode] When you register the scanned channel information, specify whether you want to register it by channel or by service.  _Default value (GR)_: Channel _Default value (BS/CS)_: Service
   * @param {boolean} [registerOnDisabled] If &#x60;true&#x60;, disable the channel setting during registration.  _Default value (GR)_: false _Default value (BS/CS)_: true
   * @param {boolean} [refresh] If &#x60;true&#x60;, update the existing settings without inheriting them. However, non-scanned types of channels will always be inherited.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConfigApi
   */
  public channelScan(
    type?: "GR" | "BS" | "CS",
    minCh?: number,
    maxCh?: number,
    minSubCh?: number,
    maxSubCh?: number,
    useSubCh?: boolean,
    registerMode?: "Channel" | "Service",
    registerOnDisabled?: boolean,
    refresh?: boolean,
    options?: any
  ) {
    return ConfigApiFp(this.configuration)
      .channelScan(
        type,
        minCh,
        maxCh,
        minSubCh,
        maxSubCh,
        useSubCh,
        registerMode,
        registerOnDisabled,
        refresh,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConfigApi
   */
  public getChannelsConfig(options?: any) {
    return ConfigApiFp(this.configuration)
      .getChannelsConfig(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConfigApi
   */
  public getServerConfig(options?: any) {
    return ConfigApiFp(this.configuration)
      .getServerConfig(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConfigApi
   */
  public getTunersConfig(options?: any) {
    return ConfigApiFp(this.configuration)
      .getTunersConfig(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {Array<ConfigChannelsItem>} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConfigApi
   */
  public updateChannelsConfig(body?: Array<ConfigChannelsItem>, options?: any) {
    return ConfigApiFp(this.configuration)
      .updateChannelsConfig(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {ConfigServer} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConfigApi
   */
  public updateServerConfig(body?: ConfigServer, options?: any) {
    return ConfigApiFp(this.configuration)
      .updateServerConfig(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {Array<ConfigTunersItem>} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConfigApi
   */
  public updateTunersConfig(body?: Array<ConfigTunersItem>, options?: any) {
    return ConfigApiFp(this.configuration)
      .updateTunersConfig(body, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * EventsApi - axios parameter creator
 * @export
 */
export const EventsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEvents: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/events`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {'program' | 'service' | 'tuner'} [resource]
     * @param {'create' | 'update' | 'redefine'} [type]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEventsStream: async (
      resource?: "program" | "service" | "tuner",
      type?: "create" | "update" | "redefine",
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/events/stream`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (resource !== undefined) {
        localVarQueryParameter["resource"] = resource
      }

      if (type !== undefined) {
        localVarQueryParameter["type"] = type
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * EventsApi - functional programming interface
 * @export
 */
export const EventsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = EventsApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEvents(
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getEvents(
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {'program' | 'service' | 'tuner'} [resource]
     * @param {'create' | 'update' | 'redefine'} [type]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEventsStream(
      resource?: "program" | "service" | "tuner",
      type?: "create" | "update" | "redefine",
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getEventsStream(
        resource,
        type,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
  }
}

/**
 * EventsApi - factory interface
 * @export
 */
export const EventsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = EventsApiFp(configuration)
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEvents(options?: any): AxiosPromise<Array<Event>> {
      return localVarFp
        .getEvents(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {'program' | 'service' | 'tuner'} [resource]
     * @param {'create' | 'update' | 'redefine'} [type]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEventsStream(
      resource?: "program" | "service" | "tuner",
      type?: "create" | "update" | "redefine",
      options?: any
    ): AxiosPromise<Array<Event>> {
      return localVarFp
        .getEventsStream(resource, type, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * EventsApi - object-oriented interface
 * @export
 * @class EventsApi
 * @extends {BaseAPI}
 */
export class EventsApi extends BaseAPI {
  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EventsApi
   */
  public getEvents(options?: any) {
    return EventsApiFp(this.configuration)
      .getEvents(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {'program' | 'service' | 'tuner'} [resource]
   * @param {'create' | 'update' | 'redefine'} [type]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EventsApi
   */
  public getEventsStream(
    resource?: "program" | "service" | "tuner",
    type?: "create" | "update" | "redefine",
    options?: any
  ) {
    return EventsApiFp(this.configuration)
      .getEventsStream(resource, type, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * LogApi - axios parameter creator
 * @export
 */
export const LogApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLog: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/log`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLogStream: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/log/stream`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * LogApi - functional programming interface
 * @export
 */
export const LogApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = LogApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLog(
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getLog(options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLogStream(
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getLogStream(
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
  }
}

/**
 * LogApi - factory interface
 * @export
 */
export const LogApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = LogApiFp(configuration)
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLog(options?: any): AxiosPromise<void> {
      return localVarFp
        .getLog(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLogStream(options?: any): AxiosPromise<void> {
      return localVarFp
        .getLogStream(options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * LogApi - object-oriented interface
 * @export
 * @class LogApi
 * @extends {BaseAPI}
 */
export class LogApi extends BaseAPI {
  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LogApi
   */
  public getLog(options?: any) {
    return LogApiFp(this.configuration)
      .getLog(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LogApi
   */
  public getLogStream(options?: any) {
    return LogApiFp(this.configuration)
      .getLogStream(options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * MiscApi - axios parameter creator
 * @export
 */
export const MiscApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    restart: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/restart`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * MiscApi - functional programming interface
 * @export
 */
export const MiscApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = MiscApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async restart(
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.restart(options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
  }
}

/**
 * MiscApi - factory interface
 * @export
 */
export const MiscApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = MiscApiFp(configuration)
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    restart(options?: any): AxiosPromise<void> {
      return localVarFp
        .restart(options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * MiscApi - object-oriented interface
 * @export
 * @class MiscApi
 * @extends {BaseAPI}
 */
export class MiscApi extends BaseAPI {
  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MiscApi
   */
  public restart(options?: any) {
    return MiscApiFp(this.configuration)
      .restart(options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * ProgramsApi - axios parameter creator
 * @export
 */
export const ProgramsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProgram: async (id: number, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("getProgram", "id", id)
      const localVarPath = `/programs/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {number} id
     * @param {number} [xMirakurunPriority]
     * @param {number} [decode]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProgramStream: async (
      id: number,
      xMirakurunPriority?: number,
      decode?: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("getProgramStream", "id", id)
      const localVarPath = `/programs/{id}/stream`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (decode !== undefined) {
        localVarQueryParameter["decode"] = decode
      }

      if (xMirakurunPriority !== undefined && xMirakurunPriority !== null) {
        localVarHeaderParameter["X-Mirakurun-Priority"] = String(
          JSON.stringify(xMirakurunPriority)
        )
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {number} [networkId]
     * @param {number} [serviceId]
     * @param {number} [eventId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPrograms: async (
      networkId?: number,
      serviceId?: number,
      eventId?: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/programs`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (networkId !== undefined) {
        localVarQueryParameter["networkId"] = networkId
      }

      if (serviceId !== undefined) {
        localVarQueryParameter["serviceId"] = serviceId
      }

      if (eventId !== undefined) {
        localVarQueryParameter["eventId"] = eventId
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ProgramsApi - functional programming interface
 * @export
 */
export const ProgramsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ProgramsApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getProgram(
      id: number,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Program>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getProgram(
        id,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {number} id
     * @param {number} [xMirakurunPriority]
     * @param {number} [decode]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getProgramStream(
      id: number,
      xMirakurunPriority?: number,
      decode?: number,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getProgramStream(
        id,
        xMirakurunPriority,
        decode,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {number} [networkId]
     * @param {number} [serviceId]
     * @param {number} [eventId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPrograms(
      networkId?: number,
      serviceId?: number,
      eventId?: number,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Program>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPrograms(
        networkId,
        serviceId,
        eventId,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
  }
}

/**
 * ProgramsApi - factory interface
 * @export
 */
export const ProgramsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ProgramsApiFp(configuration)
  return {
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProgram(id: number, options?: any): AxiosPromise<Program> {
      return localVarFp
        .getProgram(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {number} id
     * @param {number} [xMirakurunPriority]
     * @param {number} [decode]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProgramStream(
      id: number,
      xMirakurunPriority?: number,
      decode?: number,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .getProgramStream(id, xMirakurunPriority, decode, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {number} [networkId]
     * @param {number} [serviceId]
     * @param {number} [eventId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPrograms(
      networkId?: number,
      serviceId?: number,
      eventId?: number,
      options?: any
    ): AxiosPromise<Array<Program>> {
      return localVarFp
        .getPrograms(networkId, serviceId, eventId, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * ProgramsApi - object-oriented interface
 * @export
 * @class ProgramsApi
 * @extends {BaseAPI}
 */
export class ProgramsApi extends BaseAPI {
  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProgramsApi
   */
  public getProgram(id: number, options?: any) {
    return ProgramsApiFp(this.configuration)
      .getProgram(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {number} id
   * @param {number} [xMirakurunPriority]
   * @param {number} [decode]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProgramsApi
   */
  public getProgramStream(
    id: number,
    xMirakurunPriority?: number,
    decode?: number,
    options?: any
  ) {
    return ProgramsApiFp(this.configuration)
      .getProgramStream(id, xMirakurunPriority, decode, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {number} [networkId]
   * @param {number} [serviceId]
   * @param {number} [eventId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProgramsApi
   */
  public getPrograms(
    networkId?: number,
    serviceId?: number,
    eventId?: number,
    options?: any
  ) {
    return ProgramsApiFp(this.configuration)
      .getPrograms(networkId, serviceId, eventId, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * ServicesApi - axios parameter creator
 * @export
 */
export const ServicesApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLogoImage: async (
      id: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("getLogoImage", "id", id)
      const localVarPath = `/services/{id}/logo`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getService: async (id: number, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("getService", "id", id)
      const localVarPath = `/services/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {'GR' | 'BS' | 'CS' | 'SKY'} type
     * @param {string} channel
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getServiceByChannel: async (
      type: "GR" | "BS" | "CS" | "SKY",
      channel: string,
      id: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'type' is not null or undefined
      assertParamExists("getServiceByChannel", "type", type)
      // verify required parameter 'channel' is not null or undefined
      assertParamExists("getServiceByChannel", "channel", channel)
      // verify required parameter 'id' is not null or undefined
      assertParamExists("getServiceByChannel", "id", id)
      const localVarPath = `/channels/{type}/{channel}/services/{id}`
        .replace(`{${"type"}}`, encodeURIComponent(String(type)))
        .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
        .replace(`{${"id"}}`, encodeURIComponent(String(id)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {number} id
     * @param {number} [xMirakurunPriority]
     * @param {number} [decode]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getServiceStream: async (
      id: number,
      xMirakurunPriority?: number,
      decode?: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("getServiceStream", "id", id)
      const localVarPath = `/services/{id}/stream`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (decode !== undefined) {
        localVarQueryParameter["decode"] = decode
      }

      if (xMirakurunPriority !== undefined && xMirakurunPriority !== null) {
        localVarHeaderParameter["X-Mirakurun-Priority"] = String(
          JSON.stringify(xMirakurunPriority)
        )
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {'GR' | 'BS' | 'CS' | 'SKY'} type
     * @param {string} channel
     * @param {number} id
     * @param {number} [xMirakurunPriority]
     * @param {number} [decode]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getServiceStreamByChannel: async (
      type: "GR" | "BS" | "CS" | "SKY",
      channel: string,
      id: number,
      xMirakurunPriority?: number,
      decode?: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'type' is not null or undefined
      assertParamExists("getServiceStreamByChannel", "type", type)
      // verify required parameter 'channel' is not null or undefined
      assertParamExists("getServiceStreamByChannel", "channel", channel)
      // verify required parameter 'id' is not null or undefined
      assertParamExists("getServiceStreamByChannel", "id", id)
      const localVarPath = `/channels/{type}/{channel}/services/{id}/stream`
        .replace(`{${"type"}}`, encodeURIComponent(String(type)))
        .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
        .replace(`{${"id"}}`, encodeURIComponent(String(id)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (decode !== undefined) {
        localVarQueryParameter["decode"] = decode
      }

      if (xMirakurunPriority !== undefined && xMirakurunPriority !== null) {
        localVarHeaderParameter["X-Mirakurun-Priority"] = String(
          JSON.stringify(xMirakurunPriority)
        )
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {number} [serviceId]
     * @param {number} [networkId]
     * @param {string} [name]
     * @param {number} [type]
     * @param {'GR' | 'BS' | 'CS' | 'SKY'} [channelType]
     * @param {string} [channelChannel]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getServices: async (
      serviceId?: number,
      networkId?: number,
      name?: string,
      type?: number,
      channelType?: "GR" | "BS" | "CS" | "SKY",
      channelChannel?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/services`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (serviceId !== undefined) {
        localVarQueryParameter["serviceId"] = serviceId
      }

      if (networkId !== undefined) {
        localVarQueryParameter["networkId"] = networkId
      }

      if (name !== undefined) {
        localVarQueryParameter["name"] = name
      }

      if (type !== undefined) {
        localVarQueryParameter["type"] = type
      }

      if (channelType !== undefined) {
        localVarQueryParameter["channel.type"] = channelType
      }

      if (channelChannel !== undefined) {
        localVarQueryParameter["channel.channel"] = channelChannel
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {'GR' | 'BS' | 'CS' | 'SKY'} type
     * @param {string} channel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getServicesByChannel: async (
      type: "GR" | "BS" | "CS" | "SKY",
      channel: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'type' is not null or undefined
      assertParamExists("getServicesByChannel", "type", type)
      // verify required parameter 'channel' is not null or undefined
      assertParamExists("getServicesByChannel", "channel", channel)
      const localVarPath = `/channels/{type}/{channel}/services`
        .replace(`{${"type"}}`, encodeURIComponent(String(type)))
        .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ServicesApi - functional programming interface
 * @export
 */
export const ServicesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ServicesApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLogoImage(
      id: number,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getLogoImage(
        id,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getService(
      id: number,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Service>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getService(
        id,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {'GR' | 'BS' | 'CS' | 'SKY'} type
     * @param {string} channel
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getServiceByChannel(
      type: "GR" | "BS" | "CS" | "SKY",
      channel: string,
      id: number,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Service>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getServiceByChannel(
        type,
        channel,
        id,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {number} id
     * @param {number} [xMirakurunPriority]
     * @param {number} [decode]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getServiceStream(
      id: number,
      xMirakurunPriority?: number,
      decode?: number,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getServiceStream(
        id,
        xMirakurunPriority,
        decode,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {'GR' | 'BS' | 'CS' | 'SKY'} type
     * @param {string} channel
     * @param {number} id
     * @param {number} [xMirakurunPriority]
     * @param {number} [decode]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getServiceStreamByChannel(
      type: "GR" | "BS" | "CS" | "SKY",
      channel: string,
      id: number,
      xMirakurunPriority?: number,
      decode?: number,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getServiceStreamByChannel(
        type,
        channel,
        id,
        xMirakurunPriority,
        decode,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {number} [serviceId]
     * @param {number} [networkId]
     * @param {string} [name]
     * @param {number} [type]
     * @param {'GR' | 'BS' | 'CS' | 'SKY'} [channelType]
     * @param {string} [channelChannel]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getServices(
      serviceId?: number,
      networkId?: number,
      name?: string,
      type?: number,
      channelType?: "GR" | "BS" | "CS" | "SKY",
      channelChannel?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Service>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getServices(
        serviceId,
        networkId,
        name,
        type,
        channelType,
        channelChannel,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {'GR' | 'BS' | 'CS' | 'SKY'} type
     * @param {string} channel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getServicesByChannel(
      type: "GR" | "BS" | "CS" | "SKY",
      channel: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Service>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getServicesByChannel(
        type,
        channel,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
  }
}

/**
 * ServicesApi - factory interface
 * @export
 */
export const ServicesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ServicesApiFp(configuration)
  return {
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLogoImage(id: number, options?: any): AxiosPromise<void> {
      return localVarFp
        .getLogoImage(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getService(id: number, options?: any): AxiosPromise<Service> {
      return localVarFp
        .getService(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {'GR' | 'BS' | 'CS' | 'SKY'} type
     * @param {string} channel
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getServiceByChannel(
      type: "GR" | "BS" | "CS" | "SKY",
      channel: string,
      id: number,
      options?: any
    ): AxiosPromise<Array<Service>> {
      return localVarFp
        .getServiceByChannel(type, channel, id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {number} id
     * @param {number} [xMirakurunPriority]
     * @param {number} [decode]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getServiceStream(
      id: number,
      xMirakurunPriority?: number,
      decode?: number,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .getServiceStream(id, xMirakurunPriority, decode, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {'GR' | 'BS' | 'CS' | 'SKY'} type
     * @param {string} channel
     * @param {number} id
     * @param {number} [xMirakurunPriority]
     * @param {number} [decode]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getServiceStreamByChannel(
      type: "GR" | "BS" | "CS" | "SKY",
      channel: string,
      id: number,
      xMirakurunPriority?: number,
      decode?: number,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .getServiceStreamByChannel(
          type,
          channel,
          id,
          xMirakurunPriority,
          decode,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {number} [serviceId]
     * @param {number} [networkId]
     * @param {string} [name]
     * @param {number} [type]
     * @param {'GR' | 'BS' | 'CS' | 'SKY'} [channelType]
     * @param {string} [channelChannel]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getServices(
      serviceId?: number,
      networkId?: number,
      name?: string,
      type?: number,
      channelType?: "GR" | "BS" | "CS" | "SKY",
      channelChannel?: string,
      options?: any
    ): AxiosPromise<Array<Service>> {
      return localVarFp
        .getServices(
          serviceId,
          networkId,
          name,
          type,
          channelType,
          channelChannel,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {'GR' | 'BS' | 'CS' | 'SKY'} type
     * @param {string} channel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getServicesByChannel(
      type: "GR" | "BS" | "CS" | "SKY",
      channel: string,
      options?: any
    ): AxiosPromise<Array<Service>> {
      return localVarFp
        .getServicesByChannel(type, channel, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * ServicesApi - object-oriented interface
 * @export
 * @class ServicesApi
 * @extends {BaseAPI}
 */
export class ServicesApi extends BaseAPI {
  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ServicesApi
   */
  public getLogoImage(id: number, options?: any) {
    return ServicesApiFp(this.configuration)
      .getLogoImage(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ServicesApi
   */
  public getService(id: number, options?: any) {
    return ServicesApiFp(this.configuration)
      .getService(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {'GR' | 'BS' | 'CS' | 'SKY'} type
   * @param {string} channel
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ServicesApi
   */
  public getServiceByChannel(
    type: "GR" | "BS" | "CS" | "SKY",
    channel: string,
    id: number,
    options?: any
  ) {
    return ServicesApiFp(this.configuration)
      .getServiceByChannel(type, channel, id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {number} id
   * @param {number} [xMirakurunPriority]
   * @param {number} [decode]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ServicesApi
   */
  public getServiceStream(
    id: number,
    xMirakurunPriority?: number,
    decode?: number,
    options?: any
  ) {
    return ServicesApiFp(this.configuration)
      .getServiceStream(id, xMirakurunPriority, decode, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {'GR' | 'BS' | 'CS' | 'SKY'} type
   * @param {string} channel
   * @param {number} id
   * @param {number} [xMirakurunPriority]
   * @param {number} [decode]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ServicesApi
   */
  public getServiceStreamByChannel(
    type: "GR" | "BS" | "CS" | "SKY",
    channel: string,
    id: number,
    xMirakurunPriority?: number,
    decode?: number,
    options?: any
  ) {
    return ServicesApiFp(this.configuration)
      .getServiceStreamByChannel(
        type,
        channel,
        id,
        xMirakurunPriority,
        decode,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {number} [serviceId]
   * @param {number} [networkId]
   * @param {string} [name]
   * @param {number} [type]
   * @param {'GR' | 'BS' | 'CS' | 'SKY'} [channelType]
   * @param {string} [channelChannel]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ServicesApi
   */
  public getServices(
    serviceId?: number,
    networkId?: number,
    name?: string,
    type?: number,
    channelType?: "GR" | "BS" | "CS" | "SKY",
    channelChannel?: string,
    options?: any
  ) {
    return ServicesApiFp(this.configuration)
      .getServices(
        serviceId,
        networkId,
        name,
        type,
        channelType,
        channelChannel,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {'GR' | 'BS' | 'CS' | 'SKY'} type
   * @param {string} channel
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ServicesApi
   */
  public getServicesByChannel(
    type: "GR" | "BS" | "CS" | "SKY",
    channel: string,
    options?: any
  ) {
    return ServicesApiFp(this.configuration)
      .getServicesByChannel(type, channel, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * StatusApi - axios parameter creator
 * @export
 */
export const StatusApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatus: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/status`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * StatusApi - functional programming interface
 * @export
 */
export const StatusApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = StatusApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStatus(
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getStatus(
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
  }
}

/**
 * StatusApi - factory interface
 * @export
 */
export const StatusApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = StatusApiFp(configuration)
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatus(options?: any): AxiosPromise<Status> {
      return localVarFp
        .getStatus(options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * StatusApi - object-oriented interface
 * @export
 * @class StatusApi
 * @extends {BaseAPI}
 */
export class StatusApi extends BaseAPI {
  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StatusApi
   */
  public getStatus(options?: any) {
    return StatusApiFp(this.configuration)
      .getStatus(options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * StreamApi - axios parameter creator
 * @export
 */
export const StreamApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {'GR' | 'BS' | 'CS' | 'SKY'} type
     * @param {string} channel
     * @param {number} [xMirakurunPriority]
     * @param {number} [decode]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getChannelStream: async (
      type: "GR" | "BS" | "CS" | "SKY",
      channel: string,
      xMirakurunPriority?: number,
      decode?: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'type' is not null or undefined
      assertParamExists("getChannelStream", "type", type)
      // verify required parameter 'channel' is not null or undefined
      assertParamExists("getChannelStream", "channel", channel)
      const localVarPath = `/channels/{type}/{channel}/stream`
        .replace(`{${"type"}}`, encodeURIComponent(String(type)))
        .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (decode !== undefined) {
        localVarQueryParameter["decode"] = decode
      }

      if (xMirakurunPriority !== undefined && xMirakurunPriority !== null) {
        localVarHeaderParameter["X-Mirakurun-Priority"] = String(
          JSON.stringify(xMirakurunPriority)
        )
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {'program' | 'service' | 'tuner'} [resource]
     * @param {'create' | 'update' | 'redefine'} [type]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEventsStream: async (
      resource?: "program" | "service" | "tuner",
      type?: "create" | "update" | "redefine",
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/events/stream`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (resource !== undefined) {
        localVarQueryParameter["resource"] = resource
      }

      if (type !== undefined) {
        localVarQueryParameter["type"] = type
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLogStream: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/log/stream`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {number} id
     * @param {number} [xMirakurunPriority]
     * @param {number} [decode]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProgramStream: async (
      id: number,
      xMirakurunPriority?: number,
      decode?: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("getProgramStream", "id", id)
      const localVarPath = `/programs/{id}/stream`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (decode !== undefined) {
        localVarQueryParameter["decode"] = decode
      }

      if (xMirakurunPriority !== undefined && xMirakurunPriority !== null) {
        localVarHeaderParameter["X-Mirakurun-Priority"] = String(
          JSON.stringify(xMirakurunPriority)
        )
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {number} id
     * @param {number} [xMirakurunPriority]
     * @param {number} [decode]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getServiceStream: async (
      id: number,
      xMirakurunPriority?: number,
      decode?: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("getServiceStream", "id", id)
      const localVarPath = `/services/{id}/stream`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (decode !== undefined) {
        localVarQueryParameter["decode"] = decode
      }

      if (xMirakurunPriority !== undefined && xMirakurunPriority !== null) {
        localVarHeaderParameter["X-Mirakurun-Priority"] = String(
          JSON.stringify(xMirakurunPriority)
        )
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {'GR' | 'BS' | 'CS' | 'SKY'} type
     * @param {string} channel
     * @param {number} id
     * @param {number} [xMirakurunPriority]
     * @param {number} [decode]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getServiceStreamByChannel: async (
      type: "GR" | "BS" | "CS" | "SKY",
      channel: string,
      id: number,
      xMirakurunPriority?: number,
      decode?: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'type' is not null or undefined
      assertParamExists("getServiceStreamByChannel", "type", type)
      // verify required parameter 'channel' is not null or undefined
      assertParamExists("getServiceStreamByChannel", "channel", channel)
      // verify required parameter 'id' is not null or undefined
      assertParamExists("getServiceStreamByChannel", "id", id)
      const localVarPath = `/channels/{type}/{channel}/services/{id}/stream`
        .replace(`{${"type"}}`, encodeURIComponent(String(type)))
        .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
        .replace(`{${"id"}}`, encodeURIComponent(String(id)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (decode !== undefined) {
        localVarQueryParameter["decode"] = decode
      }

      if (xMirakurunPriority !== undefined && xMirakurunPriority !== null) {
        localVarHeaderParameter["X-Mirakurun-Priority"] = String(
          JSON.stringify(xMirakurunPriority)
        )
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * StreamApi - functional programming interface
 * @export
 */
export const StreamApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = StreamApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @param {'GR' | 'BS' | 'CS' | 'SKY'} type
     * @param {string} channel
     * @param {number} [xMirakurunPriority]
     * @param {number} [decode]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getChannelStream(
      type: "GR" | "BS" | "CS" | "SKY",
      channel: string,
      xMirakurunPriority?: number,
      decode?: number,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getChannelStream(
        type,
        channel,
        xMirakurunPriority,
        decode,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {'program' | 'service' | 'tuner'} [resource]
     * @param {'create' | 'update' | 'redefine'} [type]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEventsStream(
      resource?: "program" | "service" | "tuner",
      type?: "create" | "update" | "redefine",
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getEventsStream(
        resource,
        type,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLogStream(
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getLogStream(
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {number} id
     * @param {number} [xMirakurunPriority]
     * @param {number} [decode]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getProgramStream(
      id: number,
      xMirakurunPriority?: number,
      decode?: number,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getProgramStream(
        id,
        xMirakurunPriority,
        decode,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {number} id
     * @param {number} [xMirakurunPriority]
     * @param {number} [decode]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getServiceStream(
      id: number,
      xMirakurunPriority?: number,
      decode?: number,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getServiceStream(
        id,
        xMirakurunPriority,
        decode,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {'GR' | 'BS' | 'CS' | 'SKY'} type
     * @param {string} channel
     * @param {number} id
     * @param {number} [xMirakurunPriority]
     * @param {number} [decode]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getServiceStreamByChannel(
      type: "GR" | "BS" | "CS" | "SKY",
      channel: string,
      id: number,
      xMirakurunPriority?: number,
      decode?: number,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getServiceStreamByChannel(
        type,
        channel,
        id,
        xMirakurunPriority,
        decode,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
  }
}

/**
 * StreamApi - factory interface
 * @export
 */
export const StreamApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = StreamApiFp(configuration)
  return {
    /**
     *
     * @param {'GR' | 'BS' | 'CS' | 'SKY'} type
     * @param {string} channel
     * @param {number} [xMirakurunPriority]
     * @param {number} [decode]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getChannelStream(
      type: "GR" | "BS" | "CS" | "SKY",
      channel: string,
      xMirakurunPriority?: number,
      decode?: number,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .getChannelStream(type, channel, xMirakurunPriority, decode, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {'program' | 'service' | 'tuner'} [resource]
     * @param {'create' | 'update' | 'redefine'} [type]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEventsStream(
      resource?: "program" | "service" | "tuner",
      type?: "create" | "update" | "redefine",
      options?: any
    ): AxiosPromise<Array<Event>> {
      return localVarFp
        .getEventsStream(resource, type, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLogStream(options?: any): AxiosPromise<void> {
      return localVarFp
        .getLogStream(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {number} id
     * @param {number} [xMirakurunPriority]
     * @param {number} [decode]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProgramStream(
      id: number,
      xMirakurunPriority?: number,
      decode?: number,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .getProgramStream(id, xMirakurunPriority, decode, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {number} id
     * @param {number} [xMirakurunPriority]
     * @param {number} [decode]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getServiceStream(
      id: number,
      xMirakurunPriority?: number,
      decode?: number,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .getServiceStream(id, xMirakurunPriority, decode, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {'GR' | 'BS' | 'CS' | 'SKY'} type
     * @param {string} channel
     * @param {number} id
     * @param {number} [xMirakurunPriority]
     * @param {number} [decode]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getServiceStreamByChannel(
      type: "GR" | "BS" | "CS" | "SKY",
      channel: string,
      id: number,
      xMirakurunPriority?: number,
      decode?: number,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .getServiceStreamByChannel(
          type,
          channel,
          id,
          xMirakurunPriority,
          decode,
          options
        )
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * StreamApi - object-oriented interface
 * @export
 * @class StreamApi
 * @extends {BaseAPI}
 */
export class StreamApi extends BaseAPI {
  /**
   *
   * @param {'GR' | 'BS' | 'CS' | 'SKY'} type
   * @param {string} channel
   * @param {number} [xMirakurunPriority]
   * @param {number} [decode]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StreamApi
   */
  public getChannelStream(
    type: "GR" | "BS" | "CS" | "SKY",
    channel: string,
    xMirakurunPriority?: number,
    decode?: number,
    options?: any
  ) {
    return StreamApiFp(this.configuration)
      .getChannelStream(type, channel, xMirakurunPriority, decode, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {'program' | 'service' | 'tuner'} [resource]
   * @param {'create' | 'update' | 'redefine'} [type]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StreamApi
   */
  public getEventsStream(
    resource?: "program" | "service" | "tuner",
    type?: "create" | "update" | "redefine",
    options?: any
  ) {
    return StreamApiFp(this.configuration)
      .getEventsStream(resource, type, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StreamApi
   */
  public getLogStream(options?: any) {
    return StreamApiFp(this.configuration)
      .getLogStream(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {number} id
   * @param {number} [xMirakurunPriority]
   * @param {number} [decode]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StreamApi
   */
  public getProgramStream(
    id: number,
    xMirakurunPriority?: number,
    decode?: number,
    options?: any
  ) {
    return StreamApiFp(this.configuration)
      .getProgramStream(id, xMirakurunPriority, decode, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {number} id
   * @param {number} [xMirakurunPriority]
   * @param {number} [decode]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StreamApi
   */
  public getServiceStream(
    id: number,
    xMirakurunPriority?: number,
    decode?: number,
    options?: any
  ) {
    return StreamApiFp(this.configuration)
      .getServiceStream(id, xMirakurunPriority, decode, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {'GR' | 'BS' | 'CS' | 'SKY'} type
   * @param {string} channel
   * @param {number} id
   * @param {number} [xMirakurunPriority]
   * @param {number} [decode]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StreamApi
   */
  public getServiceStreamByChannel(
    type: "GR" | "BS" | "CS" | "SKY",
    channel: string,
    id: number,
    xMirakurunPriority?: number,
    decode?: number,
    options?: any
  ) {
    return StreamApiFp(this.configuration)
      .getServiceStreamByChannel(
        type,
        channel,
        id,
        xMirakurunPriority,
        decode,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * TunersApi - axios parameter creator
 * @export
 */
export const TunersApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {number} index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTuner: async (
      index: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'index' is not null or undefined
      assertParamExists("getTuner", "index", index)
      const localVarPath = `/tuners/{index}`.replace(
        `{${"index"}}`,
        encodeURIComponent(String(index))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {number} index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTunerProcess: async (
      index: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'index' is not null or undefined
      assertParamExists("getTunerProcess", "index", index)
      const localVarPath = `/tuners/{index}/process`.replace(
        `{${"index"}}`,
        encodeURIComponent(String(index))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTuners: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/tuners`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {number} index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    killTunerProcess: async (
      index: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'index' is not null or undefined
      assertParamExists("killTunerProcess", "index", index)
      const localVarPath = `/tuners/{index}/process`.replace(
        `{${"index"}}`,
        encodeURIComponent(String(index))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * TunersApi - functional programming interface
 * @export
 */
export const TunersApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = TunersApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @param {number} index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTuner(
      index: number,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TunerDevice>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getTuner(
        index,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {number} index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTunerProcess(
      index: number,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TunerProcess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getTunerProcess(
        index,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTuners(
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<TunerDevice>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getTuners(
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {number} index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async killTunerProcess(
      index: number,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.killTunerProcess(
        index,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
  }
}

/**
 * TunersApi - factory interface
 * @export
 */
export const TunersApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = TunersApiFp(configuration)
  return {
    /**
     *
     * @param {number} index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTuner(index: number, options?: any): AxiosPromise<TunerDevice> {
      return localVarFp
        .getTuner(index, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {number} index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTunerProcess(index: number, options?: any): AxiosPromise<TunerProcess> {
      return localVarFp
        .getTunerProcess(index, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTuners(options?: any): AxiosPromise<Array<TunerDevice>> {
      return localVarFp
        .getTuners(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {number} index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    killTunerProcess(index: number, options?: any): AxiosPromise<object> {
      return localVarFp
        .killTunerProcess(index, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * TunersApi - object-oriented interface
 * @export
 * @class TunersApi
 * @extends {BaseAPI}
 */
export class TunersApi extends BaseAPI {
  /**
   *
   * @param {number} index
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TunersApi
   */
  public getTuner(index: number, options?: any) {
    return TunersApiFp(this.configuration)
      .getTuner(index, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {number} index
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TunersApi
   */
  public getTunerProcess(index: number, options?: any) {
    return TunersApiFp(this.configuration)
      .getTunerProcess(index, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TunersApi
   */
  public getTuners(options?: any) {
    return TunersApiFp(this.configuration)
      .getTuners(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {number} index
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TunersApi
   */
  public killTunerProcess(index: number, options?: any) {
    return TunersApiFp(this.configuration)
      .killTunerProcess(index, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * VersionApi - axios parameter creator
 * @export
 */
export const VersionApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkVersion: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/version`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {boolean} [force]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateVersion: async (
      force?: boolean,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/version/update`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (force !== undefined) {
        localVarQueryParameter["force"] = force
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * VersionApi - functional programming interface
 * @export
 */
export const VersionApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = VersionApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async checkVersion(
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Version>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.checkVersion(
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {boolean} [force]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateVersion(
      force?: boolean,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateVersion(
        force,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
  }
}

/**
 * VersionApi - factory interface
 * @export
 */
export const VersionApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = VersionApiFp(configuration)
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkVersion(options?: any): AxiosPromise<Version> {
      return localVarFp
        .checkVersion(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {boolean} [force]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateVersion(force?: boolean, options?: any): AxiosPromise<void> {
      return localVarFp
        .updateVersion(force, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * VersionApi - object-oriented interface
 * @export
 * @class VersionApi
 * @extends {BaseAPI}
 */
export class VersionApi extends BaseAPI {
  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VersionApi
   */
  public checkVersion(options?: any) {
    return VersionApiFp(this.configuration)
      .checkVersion(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {boolean} [force]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VersionApi
   */
  public updateVersion(force?: boolean, options?: any) {
    return VersionApiFp(this.configuration)
      .updateVersion(force, options)
      .then((request) => request(this.axios, this.basePath))
  }
}
